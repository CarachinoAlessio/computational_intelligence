# Lab 2: Set Covering with Genetic Algorithms

## Problem input
The problem input is the same as lab1; it is generated by the `problem` function.
It returns a list of lists. This list is then filtered in order to reduce the computational costs: `list(set(tuple(sorted(_)) for _ in problem_out))`.
I like to call it _pool of genes_.
## First population
The first generation is generated by randomly picking at most `N` subsets from `all_lists`, where `N` is the problem size, since solutions with more than `N` subsets will not be optimal.
Finally, each element is converted into an `Individual`, which is a named tuple defined with a genome and a fitness value.
Of course, these are bad solutions for the problem but the goal is to improve them with respect to the fitness, which is defined as follows.
## Genome
The genome is a represented as a list of tuples. 
## Fitness
PAY ATTENTION: in this solution, I tried to maximize a _negative_ fitness.
When a solution is not feasible I applied a penalty term equal to -1000000000 (minus one billion).
## Crossover
One-Point crossover is exploited. The point is randomly chosen. If the child has duplicated genes (tuples), the algorithm removes the duplicates and randomly picks the missing genes from the _pool of genes_.
## Mutation
In this solution, mutation consists in randomly picking a gene from the _pool of genes_ and pushing it inside the genome.
Actually, I implemented `mutation_shut_down` that removes the gene associated to the highest bloat which is the gene that carries the elements that occur more in the whole genome.
## Mutation or Crossover?
It depends.
1) For the first half of `NUM_GENERATIONS`, these are the probabilities of selecting a genetic operator:
- mutation: **0.15**
- mutation_shut_down: **0.15**
- crossover: **0.7**
2) On the other hand, for the second half of `NUM_GENERATIONS`:
- mutation: **0.4**
- mutation_shut_down: **0.4**
- crossover: **0.2**
## Stopping criterion
After every 200 iterations, The algorythm stops when the fitness improves of <1%.
## Unused code
Inside the notebook, you can find a cell with 'Unused' code. It contains a different version of Mutation that, basically, instead of randomly picking the to-be muted gene, it selects the one that contains more 'bloat' information.

## Results

The results are generated with `SEED=42`.

| **N** | **n.elements (w)** |
|-------|--------------------|
| 5     | 5                  |
| 10    | 10                 |
| 20    | 27                 |
| 50    | 77                 |
| 100   | 182                |
| 500   | 1328               |
| 1000  | 3494               |

