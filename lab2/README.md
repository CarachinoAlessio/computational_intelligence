# Lab 2: Set Covering with Genetic Algorithms

## Problem input
The problem input is the same as lab1; it is generated by the `problem` function.
It returns a list of lists. This list is then filtered in order to reduce the computational costs: `list(set(tuple(sorted(_)) for _ in problem_out))`.
I like to call it _pool of genes_.
## First population
The first generation is generated by randomly picking at most `N` subsets from `all_lists`, where `N` is the problem size.
Finally, each element is converted into an `Individual`, which is a named tuple defined with a genome and a fitness value.
Of course, these are bad solutions for the problem but the goal is to improve them with respect to the fitness, which is defined as follows.
## Genome
The genome is a represented as a list of tuples. 
## Fitness
PAY ATTENTION: in this solution, I tried to maximize a _negative_ fitness.
When a solution is not feasible I applied a penalty term equal to -1000000000 (minus one billion).
## Crossover
One-Point crossover is exploited. The point is randomly chosen. If the child has duplicated genes (tuples), the algorithm removes the duplicates and randomly picks the missing genes from the _pool of genes_.
## Mutation
In this solution, mutation consists in randomly picking a gene from the _pool of genes_ and substituting it inside the genome.
## Unused code
Inside the notebook, you can find a cell with 'Unused' code. It contains a different version of Mutation that, basically, instead of randomly picking the to-be muted gene, it selects the one that contains more 'bloat' information.

## Results

The results are generated with `SEED=42`.

| **N** | **n.elements (w)** |
|-------|--------------------|
| 5     | 5                  |
| 10    | 11                 |
| 20    | 27                 |
| 50    | 86                 |
| 100   | 217                |
| 500   | 1475               |
| 1000  | 3614               |

