# Lab 2: Set Covering with Genetic Algorithms

## Problem input
The problem input is the same as lab1; it is generated by the `problem` function.
It returns a list of lists. This list is then filtered in order to reduce the computational costs: `list(set(tuple(sorted(_)) for _ in problem_out))`.
I like to call it _pool of genes_.
## First population
The first generation is generated by randomly picking at most `N` subsets from `all_lists`, where `N` is the problem size.
Finally, each element is converted into an `Individual`, which is a named tuple defined with a genome and a fitness value.
Of course, these are bad solutions for the problem but the goal is to improve them with respect to the fitness, which is defined as follows.
## Genome
The genome is a represented as a list of tuples. 
## Fitness
PAY ATTENTION: in this solution, I tried to maximize a _negative_ fitness.
When a solution is not feasible I applied a penalty term equal to -1000000000 (minus one billion).
## Crossover
One-Point crossover is exploited. The point is randomly chosen. If the children has duplicated genes (tuples), the algorithm removes the duplicates and randomly picks the missing genes from the _pool of genes_. 
Actually, this process is iterated a certain number of times, until it finds a feasible solution with respect to the original genome. In fact, feasible solutions are rare, considered simple concatenations of genes. This tweak is helpful more in those cases where `N` is high.
## Mutation
In this solution, mutation consists in randomly picking a gene from the _pool of genes_ and substituting it inside the genome.
Also in this case, this process is iterated a certain number of times, but this time it only finds a fitter solution with respect to the original genome. This tweak is helpful more in those cases where `N` is high.
## Results
|**N**| **n.elements (w)** |
|-----|--------------------|
| 5   | 5                  |
| 10  | 10                 |
| 20  | 25                 |
| 100 | 266                |
